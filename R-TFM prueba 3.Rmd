---
title: "TFM_Carga de paquetes"
author: "David Sánchez Sierra"
date: "2025-02-27"
output:
  html_document: default
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## TFM

```{r, echo=FALSE}
# Instalar Bioconductor si no está instalado
if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

# Paquetes a comprobar e instalar si es necesario
packages <- c("maftools", "TCGAbiolinks", "EnhancedVolcano", "ComplexHeatmap", "TCGAmutations", "MultiAssayExperiment")

# Comprobar si los paquetes están instalados y, si no, instalarlos
for (pkg in packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    BiocManager::install(pkg)
  }
}
```


```{r, echo=FALSE}
library(TCGAbiolinks)
library(dplyr)
library(DT)
library(maftools)
library(ComplexHeatmap)
library(EnhancedVolcano)
library(TCGAmutations)
library(MultiAssayExperiment)
```

```{r}
tcga_available()
```

Internamente, lo que hace es:

- Descargar el archivo MC3 completo.

- Extraer automáticamente solo las filas que pertenecen a muestras LUAD.

- Devolverlo como un objeto MAF (de maftools) listo para análisis.

```{r}
luad <- TCGAmutations::tcga_load(study = "LUAD")
luad
```
A continuación se muestra una descripción general de los datos:
```{r}
library(maftools)
getSampleSummary(luad)
getGeneSummary(luad)
plotmafSummary(luad)
```
La clase MAF tiene 8 slots, es como 8 tablas cada una con un tipo de informacion:

```{r}
slotNames(luad)
```

```{r}
# Mostrar los primeros registros de cada slot del objeto MAF

luad@data

head(luad@variants.per.sample)

head(luad@variant.type.summary)

head(luad@variant.classification.summary)

head(luad@gene.summary)

head(luad@summary)

head(luad@maf.silent)

head(luad@clinical.data)
```

En primer lugar, para la subdivision en cohortes, nos interesa el slot @data, que contiene las mutaciones y su clasificación. Una misma muestra (1 barcode) tiene varias filas que cada una corresponde a distintas mutaciones. Entonces tendremos que filtrar por el barcode de laS muestraS que nos interesan.

el Hugo Symbol es simplemente el nombre del gen en el que ocurre la mutación. Además, como el archivo MAF de MC3 (y en general los de TCGA), sólo se incluyen mutaciones que afectan a genes.

Por ende, para hacer las cohortes, se deben extraer los barcodes donde aparece al menos una vez EFGR o KRAS, y luego extraer todas las filas (mutaciones) correspondientes a esos barcodes.


Aunque antes de ello, conviene analizar los Hugo_Symbol para que todos estén correctamente identificados:



```{r}
install.packages("HGNChelper", repos = "https://cloud.r-project.org")
```


```{r}
library(HGNChelper)
x <- luad@data$Hugo_Symbol
df <- checkGeneSymbols(x)
df
```
A continuación se aceptan los sugeridos cuando existan, y se mantienen los originales cuando no haya sugerencia:

```{r}
df$Final.Symbol <- ifelse(!is.na(df$Suggested.Symbol), df$Suggested.Symbol, df$x)
df
```
Ya solo queda reemplazar los símbolos en luad@data$Hugo_Symbol por los corregidos:


```{r}
# 1. Crea un vector de mapeo nombre_original → símbolo_final
symbols_map <- setNames(df$Final.Symbol, df$x)

# 2. Reemplaza en el slot @data de tu objeto MAF
luad@data$Hugo_Symbol <- symbols_map[ luad@data$Hugo_Symbol ]
luad@data
```
Tras una inspección preliminar de las primeras filas, parece que la sustitución se ha realizado correctamente, corroborándose la equivalencia en el número de observaciones entre los conjuntos de datos. Este hallazgo sugiere una integración exitosa de la información. De manera adicional, podemos comprobar la presencia de valores faltantes en la columna "Hugo_Symbol":

```{r}
sum(is.na(luad@data$Hugo_Symbol))
```

## Cohortes 1
A continuación, se procede a la definición de cohortes mediante la extracción de los identificadores únicos (barcodes) correspondientes a las alteraciones genéticas en los genes KRAS y EGFR.

Creo que aqui hay una funcion especifica: (genesToBarcodes):	Extracts Tumor Sample Barcodes where the given genes are...
```{r}
# Extraer barcodes únicos
barcodes_kras <- unique(luad@data$Tumor_Sample_Barcode[luad@data$Hugo_Symbol == "KRAS"])
barcodes_egfr <- unique(luad@data$Tumor_Sample_Barcode[luad@data$Hugo_Symbol == "EGFR"])
length(barcodes_kras)
length(barcodes_egfr)
```
Con length hemos visto el número de **pacientes** que pertenecen a cada cohorte. En este caso, hay 157 pacientes con KRAS y 68 con EGFR.

```{r}
# Filtrar MAF para cada cohorte
library(maftools)
luad_kras <- subsetMaf(maf = luad, tsb = barcodes_kras)
luad_egfr <- subsetMaf(maf = luad, tsb = barcodes_egfr)
```
Se definieron 2 cohortes de pacientes: una con cualquier mutación en KRAS y otra con cualquier mutación en EGFR. Cada cohorte incluye todas las mutaciones detectadas en esos pacientes y se han detectado **FLAGS**

Possible FLAGS KRAS:
- MUC16
- TTN
- USH2A

Possible FLAGS EFGR:
- TTN
- MUC16
- MUC17
- USH2A


```{r}
library(maftools)
# Caracterización general
plotmafSummary(maf = luad_kras, 
               rmOutlier = TRUE, 
               addStat = 'median', 
               dashboard = TRUE, 
               titleSize = c(1.2, 1.2))

plotmafSummary(maf = luad_egfr, 
               rmOutlier = TRUE, 
               addStat = 'median', 
               dashboard = TRUE, 
               titleSize = c(1.2, 1.2))
```

```{r}
sum(luad_egfr@data$Hugo_Symbol == "TTN")
```

## Cohortes 2 - BUENA

Otra forma de definir las cohortes es usando la función `genesToBarcodes` de maftools. Esta función extrae los barcodes de las muestras donde se han detectado mutaciones en los genes especificados.

```{r}
# Definir genes de interés
genes_of_interest <- c("KRAS", "EGFR")

# Extraer barcodes para los genes de interés
barcodes <- genesToBarcodes(
  maf = luad,
  genes = genes_of_interest,
  justNames = FALSE
)
barcodes
```

```{r}
# Filtrar MAF para cada cohorte
library(maftools)
luad_kras <- subsetMaf(maf = luad, tsb = barcodes$KRAS[[1]])
luad_egfr <- subsetMaf(maf = luad, tsb = barcodes$EGFR[[1]])
```
**Búsqueda y eliminación FLAGS**
Revisar paper compartido y elegir un criterio
https://bmcmedgenomics.biomedcentral.com/articles/10.1186/s12920-017-0309-7#MOESM1

```{r}
library(maftools)
# Caracterización general
plotmafSummary(maf = luad_kras, 
               rmOutlier = TRUE, 
               addStat = 'median', 
               dashboard = TRUE, 
               titleSize = c(1.2, 1.2))

plotmafSummary(maf = luad_egfr, 
               rmOutlier = TRUE, 
               addStat = 'median', 
               dashboard = TRUE, 
               titleSize = c(1.2, 1.2))
```
# Eliminación genes FLAGS

```{r}
flags <- read.table("Tabla_FLAGS_ranked.txt", header = FALSE, stringsAsFactors = FALSE)
flags
```

```{r}
flags_eliminar <- flags$V1[1:50]
flags_eliminar
```
```{r}
todos_los_genes <- getGeneSummary(luad)$Hugo_Symbol
genes_a_mantener <- setdiff(todos_los_genes, flags_eliminar)
summary(genes_a_mantener)
```

```{r}
library(maftools)
maf_KRAS_SinFlags <- subsetMaf(
  maf = luad_kras, 
  genes = genes_a_mantener,
  )
maf_KRAS_SinFlags
```


# Visualización
- Oncoplots: ya los conoces, muestran qué genes están más mutados en qué pacientes.

- Lollipop plots: muestran en qué parte de la proteína están ocurriendo las mutaciones (ej. dominios funcionales).

- Summary plots: resumen general de cuántas mutaciones hay y de qué tipo.

- Ti/Tv plots: muestran la proporción de transiciones vs. transversiones (tipos de mutaciones puntuales).

- Rainfall plots: sirven para detectar patrones tipo kataegis.


### Oncoplots

```{r}
# Oncoplots de los genes más mutados
oncoplot(maf = luad_kras, top = 10)
oncoplot(maf = luad_egfr, top = 10)
```
La Figura generada se denomina oncoplot, muestra los genes significativamente mutados (False discovery rate (FDR) < 0.1) identificados mediante el algoritmo MutSigCV (Lawrence et al. 2013b). Eso quiere decir que solo el 10% son falsos.
Los genes se ordenan según su frecuencia mutacional. El gráfico de barras lateral muestra los valores Q transformados en log10, estimados por el algoritmo MutSigCV.

Como todos los pacientes tienen la misma histología (LUAD), no hay subgrupos morfológicos o histológicos adicionales. Hay opciones disponibles para incluir anotaciones como barras de anotación en la parte inferior para mostrar parámetros clínicos.


```{r}
library(maftools)

# Comparación lado a lado de los genes más mutados en ambas cohortes
coOncoplot(m1 = luad_kras, 
           m2 = luad_egfr,
           m1Name = "LUAD KRAS", 
           m2Name = "LUAD EGFR", 
           genes = NULL, # o puedes poner un vector de genes si quieres forzar algunos
           removeNonMutated = TRUE)
```

###  Transiciones y transversiones plot

El gráfico de transiciones y transversiones (Figura 2B) resume las SNV (variantes de un solo nucleótido) en seis categorías.El gráfico de barras apiladas inferior muestra la distribución del espectro mutacional por muestra del archivo MAF.

```{r}
# Para LUAD con mutaciones en KRAS
titv_kras <- titv(maf = luad_kras, plot = FALSE)
plotTiTv(titv_kras)

# Para LUAD con mutaciones en EGFR
titv_egfr <- titv(maf = luad_egfr, plot = FALSE)
plotTiTv(titv_egfr)
```

###  Lollipop plots

Los gráficos lollipop (o "lollipop plots") en el contexto de maftools son representaciones visuales de las mutaciones de un gen específico a lo largo de su estructura proteica lineal. Para mantener la coherencia en el diseño de los gráficos, los lollipop plots generados por Maftools siguen la misma estética visual que las herramientas en línea comúnmente utilizadas, como las disponibles en cBioPortal. 

Lollipop plot que muestra la distribución de mutaciones y dominios proteicos del gen, con los puntos calientes recurrentes etiquetados. La tasa de mutación somática y los nombres de transcritos se indican en el título y subtítulo del gráfico, respectivamente.

El eje horizontal (x) es la longitud del gen/proteína, cada "piruleta" indica una posición donde ocurre una mutación. El tallo llega hasta el eje, marcando la posición del cambio y su altura es la frecuencia mutacional. El círculo muestra el tipo de mutación (con un color).

Los dominios proteicos se representan como rectángulos de colores en el fondo del gráfico. Muestran regiones funcionales de la proteína (por ejemplo, dominios de unión, regiones catalíticas...).

Sirven para dentificar hotspots de mutación (regiones que se mutan frecuentemente) t ver si las mutaciones caen en dominios funcionales.

```{r}
library(maftools)

lollipopPlot(maf = luad_kras, gene = "TP53", AACol = "HGVSp_Short")
lollipopPlot(maf = luad_egfr, gene = "TP53", AACol = "HGVSp_Short")
```

### Rainfall plots
Varios estudios han reportado regiones genómicas hipermutadas en distintos tipos de cáncer. Estas regiones, conocidas como Kataegis, se cree que son el resultado de una actividad anómala de las desaminasas de citidina tipo APOBEC (enzimas similares a la APOBEC, que editan ARN mensajero de apolipoproteína B).

Estas regiones suelen estar enriquecidas en sustituciones C>T y C>G que ocurren dentro de trinucleótidos TpCpN (donde “N” puede ser cualquier nucleótido).

La función rainfallPlot de Maftools permite visualizar la distribución del espectro mutacional al mismo tiempo que identifica las regiones tipo Kataegis.

EN los rainfall plots, cada punto representa una mutación y el eje x es la posición genómica. El eje y es la distancia entre mutaciones en el genoma. Las mutaciones están coloreadas según su tipo (ej. transiciones, transversiones, etc.). Las líneas horizontales indican regiones de alta densidad de mutaciones.

Los segmentos genómicos hipermutados identificados por el método change-point están resaltados con cabezas de flecha negras.

```{r}
rainfallPlot(
  maf = luad_kras,
  tsb = NULL,
  detectChangePoints = TRUE,
  ref.build = "hg19",
  color = NULL,
  savePlot = FALSE,
  width = 6,
  height = 3,
  fontSize = 1.2,
  pointSize = 0.4
)
```
- **tsb**: Especifica los nombres de las muestras (Tumor_Sample_Barcodes) para las cuales se debe realizar el gráfico. Si es `NULL`, se dibuja el gráfico para la muestra más mutada.
- **detectChangePoints**: Si es `TRUE`, detecta puntos de cambio genómicos donde podrían formarse Kataegis. Los resultados se escriben en un archivo de salida en formato delimitado por tabuladores.
- **ref.build**: Construcción de referencia para los tamaños de los cromosomas. Puede ser hg18, hg19 o hg38. El valor por defecto es `hg19`.
- **color**: Un vector nombrado de colores para cada clase de conversión.
- **savePlot**: Si es `TRUE`, el gráfico se guarda en un archivo PDF. El valor por defecto es `FALSE`.

El algoritmo de detección de Kataegis fue desarrollado por Moritz Goretzky en la WWU Münster, y explota la definición de Kataegis (seis mutaciones consecutivas con una distancia promedio de 1000 pb) para identificar loci genómicos hipermutados. El algoritmo comienza con una cola doble, a la que se agregan seis mutaciones consecutivas y se calcula su distancia promedio de intermutación. Si la distancia promedio de intermutación es mayor a 1000, se agrega un elemento al final de la cola y se elimina uno desde el principio. Si la distancia promedio de intermutación es menor o igual a 1000, se añaden más mutaciones hasta que la distancia promedio de intermutación sea mayor a 1000. Después de eso, todas las mutaciones en la cola doble se escriben en la salida como un Kataegis y la cola doble se reinicia con seis mutaciones.





Además, Maftools también permite visualizar y resumir datos de número de copia (CNV) generados por herramientas como GISTIC o segmentaciones hechas por algoritmos tipo CBS. Estos datos pueden integrarse fácilmente con las mutaciones, permitiendo un análisis más completo.



# Análisis MAFTOOLs

### 0.Resumen Cohortes con Mafsummary

```{r}
library(maftools)
# Caracterización general
plotmafSummary(maf = luad_kras, 
               rmOutlier = TRUE, 
               addStat = 'median', 
               dashboard = TRUE, 
               titleSize = c(1.2, 1.2))

plotmafSummary(maf = luad_egfr, 
               rmOutlier = TRUE, 
               addStat = 'median', 
               dashboard = TRUE, 
               titleSize = c(1.2, 1.2))
```

### 1.Comparación de cohortes y resumen de dominios Pfam.

Pfam es una base de datos de familias de proteínas y dominios funcionales. Por ende es hacer un resumen de los dominios proteicos afectados por las mutaciones, usando la base de datos Pfam.

#### 1.1 mafcompare (genes diferencialmente mutados)

mafcompare() permite comparar dos objetos MAF y resumir las diferencias entre ellos. En este caso, se comparan las cohortes de KRAS y EGFR.

DMGs: Genes mutacionalmente distintos (differentially mutated genes).

La carga mutacional es comparada por Fisher’s exact
tests.

```{r}
mafCompare_kras_vs_egfr <- maftools::mafCompare(
  m1 = luad_kras,
  m2 = luad_egfr,
  m1Name = "KRAS",
  m2Name = "EGFR",
  minMut = 5
)
cohort_colors <- c("LUAD_KRAS" = "red", "LUAD_EGFR" = "blue")

forest_Kras_vs_EGFR <- forestPlot(
  mafCompareRes = mafCompare_kras_vs_egfr,
  pVal = 0.015,
  color = as.character(unlist(cohort_colors)),
  geneFontSize = 0.7
)
forest_Kras_vs_EGFR
```
El "Odds Ratio" (OR) es la razón de probabilidades de que un gen esté mutado en una cohorte frente a la otra. (Inf es de infinito)

```{r}
# Guardar como imagen PNG
png("forest_plot_kras_vs_egfr.png", width = 800, height = 600)
maftools::forestPlot(
  mafCompareRes = mafCompare_kras_vs_egfr,
  pVal = 0.01,
  color = as.character(unlist(cohort_colors)),
  geneFontSize = 1.3,
  titleSize = 2,
  lineWidth = 2.5
)
dev.off()
```

```{r}
mafCompare_kras_vs_egfr$results  
```

```{r}
sum(mafCompare_kras_vs_egfr$results$pval < 0.01)
```

Se revelan que 15 genes son significativamente mutados entre las cohortes de KRAS y EGFR. En el gráfico, los genes están ordenados por el valor p ajustado (FDR) y se muestran los valores de OR (odds ratio) para cada gen.

*Recordando*:
- p-valor (pval): probabilidad de obtener los datos observados por azar, sin corrección.

- p-valor ajustado (FDR o p.adjust): se aplica una corrección (como Benjamini-Hochberg) para reducir el número de falsos descubrimientos debidos al gran número de comparaciones.

```{r}
res_mafComp <- mafCompare_kras_vs_egfr$results

# Filtra por pval < 0.01 y or > 1
sig_genes_kras <- res_mafComp[
  res_mafComp$pval < 0.01 &    # raw p-value
  res_mafComp$or   > 1,        # more mutated in KRAS
  "Hugo_Symbol"
]
sig_genes_kras
```

```{r}
# Filtra por pval < 0.01 y or > 1
sig_genes_egfr <- res_mafComp[
  res_mafComp$pval < 0.01 &    # raw p-value
  res_mafComp$or   < 1,        # more mutated in KRAS
  "Hugo_Symbol"
]
sig_genes_egfr
```



La mayoría estan en KRAS (en el paper 28 la mayoría también estan en una de las cohortes, y apoya la explicacion con los *enrichment*)

#### 1.2 pfamDomains (dominios proteicos diferencialmente mutados)

*pfamDomains* de maftools realiza un análisis de enriquecimiento de dominios proteicos. Agrupar los dominios proteicos ayuda a identificar las vías más desreguladas y las familias de proteínas implicadas en funciones similares.

```{r}
kras.pfam <- pfamDomains(
  maf = luad_kras,
  AACol = NULL,
  summarizeBy = "AAPos",
  top = 5,
  domainsToLabel = NULL,
  baseName = NULL,
  varClass = "nonSyn",
  width = 5,
  height = 5,
  labelSize = 1
)
kras.pfam

egfr.pfam <- pfamDomains(
  maf = luad_egfr,
  AACol = NULL,
  summarizeBy = "AAPos",
  top = 5,
  domainsToLabel = NULL,
  baseName = NULL,
  varClass = "nonSyn",
  width = 5,
  height = 5,
  labelSize = 1
)
egfr.pfam
```
En summarizeBy:

- “AAPos”: Agrupa todas las mutaciones que caen en la misma posición de aminoácido, independientemente del tipo de sustitución (p. ej., p.R175H y p.R175C se cuentan juntas en la posición 175). Es útil cuando te interesa el hotspot en un residuo concreto, sin distinguir la naturaleza exacta del cambio.

- “AAChange”: Agrupa cada variante por cambio específico de aminoácido, distinguiendo p.R175H de p.R175C aunque comparten posición. Se utiliza cuando quieres cuantificar mutaciones por tipo de sustitución, lo cual puede revelar sesgos en la naturaleza biológica de las variantes (por ejemplo, transiciones vs. transversiones).

```{r}
names(kras.pfam)
```

```{r}
kras_domains <- kras.pfam$domainSummary
egfr_domains <- egfr.pfam$domainSummary
kras_domains
egfr_domains
```
Representación visual:

```{r}
library(ggplot2)
library(ggrepel)
library(dplyr)

# Elegir los 10 dominios más mutados
top10_kras <- kras_domains %>% 
  slice_max(nMuts, n = 10)

rest_kras <- anti_join(kras_domains, top10_kras, by = "DomainLabel")

top10_egfr <- egfr_domains %>% 
  slice_max(nMuts, n = 10)
rest_egfr <- anti_join(egfr_domains, top10_egfr, by = "DomainLabel")

kras_plot <- ggplot() +
  geom_point(data = rest_kras, aes(x = nMuts, y = nGenes, size = 0.5), color = "grey", alpha = 0.6) +
  geom_point(data = top10_kras, aes(x = nMuts, y = nGenes, size = nMuts), color = "red") +
  geom_text_repel(
    data = top10_kras,
    aes(x = nMuts, y = nGenes, label = DomainLabel),
    color = "red",
    size = 4,  # ← más grande
    box.padding = 0.3,
    max.overlaps = Inf,
    force = 1.5
  ) +
  scale_size_continuous(range = c(2, 6)) +
  labs(
    x = "# mutations",
    y = "# genes",
    title = "KRAS – Pfam domain mutations"
    # size eliminado del título
  ) +
  guides(size = "none") +  # ← quita leyenda
  theme_minimal(base_size = 12)+
  theme(
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.6)
  )

ggsave("kras_pfam_plot_forzado.png", kras_plot, width = 6, height = 5, dpi = 300)

# Mostrar el gráfico
print(kras_plot)
```


```{r}
egfr_plot <- ggplot() +
  geom_point(data = rest_egfr, aes(x = nMuts, y = nGenes, size = 0.5), color = "grey", alpha = 0.6) +
  geom_point(data = top10_egfr, aes(x = nMuts, y = nGenes, size = nMuts), color = "blue") +
  geom_text_repel(
    data = top10_egfr,
    aes(x = nMuts, y = nGenes, label = DomainLabel),
    color = "blue",
    size = 4,  # ← más grande
    box.padding = 0.3,
    max.overlaps = Inf,
    force = 1.5
  ) +
  scale_size_continuous(range = c(2, 6)) +
  labs(
    x = "# mutations",
    y = "# genes",
    title = "EGFR – Pfam domain mutations"
    # size eliminado del título
  ) +
  guides(size = "none") +  # ← quita leyenda
  theme_minimal(base_size = 12) +
  theme(
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.6)
  )

ggsave("egfr_pfam_plot_forzado.png", egfr_plot, width = 6, height = 5, dpi = 300)

# Mostrar el gráfico
print(egfr_plot)
```

Cribado:

```{r}
kras_top20 <- kras_domains %>%
  slice_head(n = 20) %>%
  select(DomainLabel) %>%
  mutate(KRAS = TRUE)

egfr_top20 <- egfr_domains %>%
  slice_head(n = 20) %>%
  select(DomainLabel) %>%
  mutate(EGFR = TRUE)
kras_top20
egfr_top20
```


```{r}
# Unir y ver qué dominios están en KRAS, EGFR o ambos
domain_comparison <- full_join(kras_top20, egfr_top20, by = "DomainLabel") %>%
  # sustituir NAs por FALSE
  mutate(
    KRAS = if_else(is.na(KRAS), FALSE, KRAS),
    EGFR = if_else(is.na(EGFR), FALSE, EGFR)
  ) %>%
  # crear la clasificación
  mutate(classification = case_when(
    KRAS & EGFR ~ "common",
    KRAS        ~ "KRAS",
    EGFR        ~ "EGFR"
  )) %>%
  # seleccionar solo DomainLabel y classification
  select(DomainLabel, classification)

domain_comparison
```
```{r}
domain_comparison_final <- domain_comparison %>%
  left_join(
    kras_domains %>% select(DomainLabel, Description),
    by = "DomainLabel"
  )

domain_comparison_final
```

El dominio COG1100 no está entre los 25 mas mutados de EGFR, pero sí en KRAS. Lo mismo con S_TKc, EGF_CA, LIC y PTPc.

En cambio, pasa al contrario con PTKc_EGFR,	WD40,	MYSc, P53 y PDZ_signaling.

Tenemos en total 9 dominios que difieren entre cohortes, los cuales pueden suscitar diferencias en vias de señalización o funciones celulares.


```{r}
options(repos = c(CRAN = "https://cloud.r-project.org"))
install.packages("openxlsx")
```




```{r}
# Guardar el dataframe como un archivo Excel
library(openxlsx)
write.xlsx(domain_comparison_final, file = "domain_comparison_filter.xlsx")
```


###2. Análisis de firmas mutacionales: Índice de correlación cophenética 

Alexandrov et al. (2013a) han demostrado que estos procesos mutagénicos pueden ser identificados utilizando técnicas de reducción dimensional, como la factorización de matrices no negativa (NMF). Específicamente, este método clasifica las SNVs en seis diferentes eventos de transición y transversión, cada uno de los cuales se clasifica en 16 subtipos basados en las bases inmediatas 5′ y 3′ que rodean la base mutada (Nik-Zainal et al. 2012; Alexandrov et al. 2013a). El análisis típico de firmas de novo incluye la generación de una matriz de frecuencias y la descomposición por NMF. 

Implementamos dos funciones, denominadas trinucleotideMatrix y extractSignatures (signature es como firma, patrón distintivo de mutación), para agilizar todo el proceso. Además, extendimos este análisis mediante la función signatureEnrichment  para realizar estratificación de muestras, enriquecimiento de firmas y análisis de asociación.

Las firmas mutacionales son "combinaciones" específicas de mutaciones que se encuentran con frecuencia en ciertos tipos de cáncer y que están asociadas con diferentes procesos o factores mutagénicos. Por ejemplo:

Firma mutacional asociada al tabaco:
Firma mutacional asociada a defectos en la reparación del ADN

La correlación cophenética permite evaluar la calidad de un análisis de agrupamiento jerárquico. En el análisis de firmas mutacionales, las técnicas de descomposición de matrices como la factorización de matrices no negativas (NMF) se usan para descomponer el conjunto de datos en "firmas" de mutación.

El índice de correlación cophenética compara la distancia entre los grupos de datos (en este caso, los patrones de mutación) en un dendrograma con las distancias reales entre los puntos de datos. 

En el caso de este estudio, se utilizaron los resultados del análisis de firmas mutacionales y se aplicó un agrupamiento jerárquico para identificar patrones comunes de mutación en ESCC (carcinoma esofágico de células escamosas) y EAC (adenocarcinoma esofágico). A través de la correlación cophenética, pudieron validar cuántos subtipos de firmas mutacionales existían en cada tipo de cáncer. Los resultados indicaron que había tres firmas en ESCC y cinco firmas en EAC, con una baja tasa de falsos positivos.

Es decir, encontraron 3 y 5 "patrones mutacionales", respectivamente. Por ejemplo alomejor en ESCC encuentras que se repiten muchas mutaciones por cambio de A a G (por decir un ejemplo) mientras que en EAC puedes encontrar que hay muchas mutaciones en pacientes que comparten una adiccion (fumar o mascar chicle, por decir otro ejemplo disparatado)

```{r}
install.packages("NMF")
```


```{r}
library(NMF)
```

```{r, error=TRUE}
install.packages("D:/Máster Bioinformática/BSgenome.Hsapiens.UCSC.hg19_1.4.3.tar", repos = NULL, type = "source")
```

```{r, error=TRUE}
install.packages("D:/Máster Bioinformática/BSgenome.Hsapiens.UCSC.hg38_1.4.5.tar.gz",
                 repos = NULL,
                 type = "source")
```

```{r}
# Cargar el genoma
library(BSgenome.Hsapiens.UCSC.hg19)
```

```{r}
BSgenome.Hsapiens.UCSC.hg19
```


```{r}
library(maftools)
library(maftools)

tri_kras <- trinucleotideMatrix(
  maf        = luad_egfr,
  ref_genome = "BSgenome.Hsapiens.UCSC.hg19",  # cadena, para que maftools valide el paquete
  prefix     = "chr",                         # añade "chr" delante de "10" → "chr10"
  add        = TRUE
)
```

Se ha generado previamente la matriz de trinucleótidos. A continuación, para estimar firmas de mutación, se emplea la función extractSignatures. Esta función aplica la factorización de matrices no negativa (NMF) a la matriz de trinucleótidos. Con ello, se descompone la matriz en un número especificado de firmas y se devuelve una lista que contiene las firmas identificadas y sus pesos correspondientes.

Previamente a la extracción de firmas, es necesario calcular los parámetros óptimos de ciertas métricas:

```{r}
library(NMF)
library(maftools)

# tri_kras es una lista: elemento 1 = matriz de mutaciones
mat_kras <- tri_kras[[1]]

# 1. Estimar rango de firmas (de 2 a 6)
est <- nmfEstimateRank(
  mat_kras,
  range  = 2:6,
  method = "brunet",
  nrun   = 10,      # repeticiones para estabilidad
  seed   = 123456,
  .opt   = "p4"     # usa 4 núcleos
)

# 2. Graficar el coeficiente cofenético vs. número de firmas
plot(est)
```

Cophenetic correlation coefficient (cophenetic)
Mide la estabilidad del clustering a medida que aumentas el número de firmas. Valores más altos indican que las asignaciones de firmas a muestras son más consistentes entre ejecuciones.


```{r}
signatures_kras  <- extractSignatures(
  mat = tri_kras,
  n = 4,  #decompose matrix into n signatures. Default NULL. Tries to predict best value for n by running NMF on a range of values and chooses based on cophenetic correlation coefficient.
  plotBestFitRes = FALSE,
  parallel = 4,
  pConstant = NULL  #A small positive value to add to the matrix. Use it ONLY if the functions throws an non-conformable arrays error
)
```

Supuestamente poniendo NULL deberia haber hecho lo del código anterior, pero bueno. Como n=4, hemos extraído 4 firmas:

```{r}
plotSignatures(signatures_kras)
```
Con sig_db = "legacy", plotSignatures() superpone la firma extraída con la firma de referencia de la base “legacy” de COSMIC, escalando o ajustando tus datos para compararlos con esa referencia. 

“Quiero comparar las firmas que yo acabo de descubrir con las firmas ya conocidas que existen en una base llamada COSMIC legacy”.

La función calcula la similitud coseno entre tu firma de novo y las firmas de referencia para determinar la mejor coincidencia, donde valores cercanos a 1 indican perfiles muy similares.

El prefijo SBS forma parte de la versión moderna de COSMIC (v3+), mientras que COSMIC_<n> corresponde a la nomenclatura legacy (v2).

- Mayor cobertura y actualización continua: COSMIC v3 incluye más firmas (65+ en v3.4) extraídas de miles de genomas y exomas con metodologías refinadas (SigProfiler).

- Consistencia con herramientas actuales: Paquetes como Sigminer y las versiones más recientes de maftools usan por defecto sig_db = "SBS", integrando directamente la base SBS de COSMIC 
Razón.




Una vez extraídas las firmas mutacionales con extractSignatures():

- Estratificar tus pacientes según la firma que predomina en ellos.

- Determinar qué firmas están enriquecidas en ciertos grupos de pacientes (por ejemplo, con mutación en KRAS vs EGFR).

Antes se usaba `signatureEnrichment()` para determinar qué firmas estaban enriquecidas, pero está obsoleta.

```{r}
BiocManager::install("sigminer", dependencies = TRUE)
```

```{r}
library(sigminer)
```



#### Alternativa: paquete Sigminer: https://shixiangwang.github.io/sigminer-book/target-vis.html

En paper 28, con el análisis de firmas mutacionales, encontraron:

- El 26% de los tumores ESCC estaban enriquecidos en mutaciones asociadas a APOBEC.

- Este mecanismo no estaba activo en EAC.

- Los tumores con enriquecimiento APOBEC tenían significativamente más mutaciones.










### 3.Somatic Interactions

*somaticInteractions* facilita la identificación de conjuntos de genes mutados de forma mutuamente excluyente o concurrente (co-ocurrencia).

El ejemplo perfecto es kras y EGFR, solo hay 1 paciente que comparta mutaciones en ambos genes.

Otras excluyentes conocidas son TP53/FLT3, NPM1/FLT3

top = 25 y genes = NULL lo que hace es seleccionar los 25 genes que más mutaciones acumulan y compararlos entre sí.

Entonces se podría hacer un análisis del MAF general o de cada subcohorte, el problema es que creo que el general no tiene sentido porque EGFR genera mas mutaciones, por lo tanto coexisten mas y son mayoritariamente esos genes los que el análisis usa.

```{r}
somaticInteractions(
  maf = luad,
  top = 25,
  genes = NULL,
  pvalue = c(0.05, 0.01),
  returnAll = TRUE,
  geneOrder = NULL,
  fontSize = 0.8,
  showSigSymbols = TRUE,
  showCounts = FALSE,
  countStats = "all",
  countType = "all",
  countsFontSize = 0.8,
  countsFontColor = "black",
  colPal = "BrBG",
  showSum = TRUE,
  colNC = 9,
  nShiftSymbols = 5,
  sigSymbolsSize = 2,
  sigSymbolsFontSize = 0.9,
  pvSymbols = c(46, 42),
  limitColorBreaks = TRUE
)
```
```{r}
somaticInteractions(
  maf = luad_egfr,
  top = 25,
  genes = NULL,
  pvalue = c(0.05, 0.01),
  returnAll = TRUE,
  geneOrder = NULL,
  fontSize = 0.8,
  showSigSymbols = TRUE,
  showCounts = FALSE,
  countStats = "all",
  countType = "all",
  countsFontSize = 0.8,
  countsFontColor = "black",
  colPal = "BrBG",
  showSum = TRUE,
  colNC = 9,
  nShiftSymbols = 5,
  sigSymbolsSize = 2,
  sigSymbolsFontSize = 0.9,
  pvSymbols = c(46, 42),
  limitColorBreaks = TRUE
)
```

```{r}
somaticInteractions(
  maf = luad_kras,
  top = 25,
  genes = NULL,
  pvalue = c(0.05, 0.01),
  returnAll = TRUE,
  geneOrder = NULL,
  fontSize = 0.8,
  showSigSymbols = TRUE,
  showCounts = FALSE,
  countStats = "all",
  countType = "all",
  countsFontSize = 0.8,
  countsFontColor = "black",
  colPal = "BrBG",
  showSum = TRUE,
  colNC = 9,
  # nShiftSymbols = 5,
  sigSymbolsSize = 2,
  sigSymbolsFontSize = 0.9,
  pvSymbols = c(46, 42),
  limitColorBreaks = TRUE
)
```
```{r}
somaticInteractions(
  maf = maf_KRAS_SinFlags,
  top = 25,
  genes = NULL,
  pvalue = c(0.05, 0.01),
  returnAll = TRUE,
  geneOrder = NULL,
  fontSize = 0.8,
  showSigSymbols = TRUE,
  showCounts = FALSE,
  countStats = "all",
  countType = "all",
  countsFontSize = 0.8,
  countsFontColor = "black",
  colPal = "BrBG",
  showSum = TRUE,
  colNC = 9,
  nShiftSymbols = 5,
  sigSymbolsSize = 2,
  sigSymbolsFontSize = 0.9,
  pvSymbols = c(46, 42),
  limitColorBreaks = TRUE
)
```


De hecho, en los LUAD kras hay 5 pares de genes mutuamente excluyentes, mientras que en los LUAD egfr hay 0. 

En el caso de los LUAD kras, los genes son:	KEAP1/LRP1B, STK11/TP53, STK11/RP1L1, STK11/ZNF536 y STK11/XIRP2

```{r}
oncoplot(
  maf = luad_kras,
  genes = c("KEAP1", "LRP1B"),
  drawRowBar = FALSE, 
  drawColBar = FALSE,
  removeNonMutated = TRUE
)
```

- KEAP1 (proteína asociada a ECH tipo Kelch 1) es una proteína que actúa como regulador negativo del factor de transcripción Nrf2, un componente clave en la defensa celular contra el estrés oxidativo. KEAP1 funciona principalmente como una ligasa E3 de ubiquitina, dirigiendo a Nrf2 hacia su degradación, y también actúa como sensor del estrés oxidativo y electrofílico.

- LRP1B, o proteína relacionada con el receptor de lipoproteínas de baja densidad 1B, es una proteína y un potencial supresor tumoral. Es miembro de la familia de receptores de lipoproteínas de baja densidad (LDL) y con frecuencia se encuentra alterada en varios tipos de cáncer. LRP1B se considera un supresor tumoral porque su inactivación se observa comúnmente en cáncer, y su expresión puede inhibir el crecimiento, la migración y la metástasis de células tumorales en ciertos tipos de cáncer. Las mutaciones en LRP1B se han asociado a mejores resultados con inhibidores de puntos de control inmunitario (ICIs) en múltiples tipos de cáncer.

Keap1 SMARCA4 y STK11 --> Buscar y hacer oncoplot
Y P53 tambien tiene que anda por ahi

### 4.Detector oncodrivers

Para facilitar esta detección, se creó una función llamada oncodrive basada en el algoritmo OncodriveCLUST, que aprovecha la observación de que la mayoría de las mutaciones activadoras dentro de oncogenes están agrupadas en puntos críticos mutacionales (mutational hotspots) (Tamborero et al. 2013).

Sin embargo, como se mencionó en el estudio original, oncodrive tiene un sesgo hacia oncogenes con hotspots mutacionales, y su rendimiento es menor al identificar posibles genes supresores de tumores, como TP53, cuyas mutaciones suelen estar distribuidas aleatoriamente a lo largo del gen.

```{r}
test_oncogenes_1 <- oncodrive(
  maf = luad,
  AACol = NULL,
  minMut = 5,
  pvalMethod = "zscore",
  nBgGenes = 100,
  bgEstimate = TRUE,
  ignoreGenes = NULL
)
```
```{r}
test_oncogenes_2 <- oncodrive(
  maf = luad,
  AACol = NULL,
  minMut = 10,
  pvalMethod = "zscore",
  nBgGenes = 100,
  bgEstimate = TRUE,
  ignoreGenes = NULL
)
```

```{r}
test_oncogenes_3 <- oncodrive(
  maf = luad,
  AACol = NULL,
  minMut = 15,
  pvalMethod = "zscore",
  nBgGenes = 100,
  bgEstimate = TRUE,
  ignoreGenes = NULL
)
```
**Ventaja:**

- Permite explorar modelos de inclusión de genes de distinta frecuencia para valorar la estabilidad de las predicciones.

**Limitaciones:**

- Sesgo hacia genes muy mutados: al aumentar minMut, los drivers raros quedan fuera.

- Penalización FDR: cuantos más genes (pruebas), más conservadora la corrección.

- Dependencia de parámetros: no hay un “mejor” valor universal de minMut; varía según cohortes y cobertura de secuenciación.

**Alternativas y mejoras recomendadas**
1. Integrar métodos complementarios
- OncodriveFML (focaliza en impacto funcional): supera el sesgo de clúster (Nature).

- MutSigCV (modelo de covariables mutacionales) y dNdScv (modela dN/dS en genes): incorporan contexto genómico y tasa de mutación de fondo 

- 20/20+ (clasificador de drivers basado en múltiples características): combina frecuencia y patrón mutacional.

2. Validación cruzada y consenso

3. Ajuste de parámetros basado en datos (optmizar minmut)

- Curva ROC si tienes una verdad de oro (genes conductores conocidos).

- Estabilidad de FDR: elige el punto donde la tasa de nuevos genes se estabiliza.

```{r}
p <- plotOncodrive(res = test_oncogenes_2, useFraction = TRUE, fdrCutOff = 0.1)
```


```{r}
test_oncogenes_2
colnames(test_oncogenes_2)
```


```{r}
library(ggplot2)
library(ggrepel)

df <- test_oncogenes_2
df$negLog10FDR <- -log10(df$fdr)

ggplot(df, aes(x = fract_muts_in_clusters, y = negLog10FDR)) +
  geom_point(aes(size = muts_in_clusters, fill = clusterScores),
             shape = 21, color = "black", alpha = 0.7) +
  # solo etiquetamos los genes con fdr < 0.20
  geom_text_repel(data = subset(df, fdr < 0.20),
                  aes(label = Hugo_Symbol),
                  max.overlaps = Inf,
                  size = 3) +
  scale_size_continuous(name = "Mutaciones en clúster") +
  scale_fill_gradient(name = "Score\nde clúster") +
  labs(x = "Fracción de mutaciones en clústeres",
       y = "-log10(FDR)") +
  theme_bw()
```



```{r}
test_oncogenes_1
test_oncogenes_2
test_oncogenes_3
```
##### 1ª Aproximación - Uso de varios "n": 
```{r}
library(dplyr)

filtered_1 <- test_oncogenes_1 %>% filter(pval < 0.01, fdr < 0.3)
filtered_2 <- test_oncogenes_2 %>% filter(pval < 0.01, fdr < 0.2)
filtered_3 <- test_oncogenes_3 %>% filter(pval < 0.01, fdr < 0.1)

# Ver resultados
filtered_1
filtered_2
filtered_3
```

```{r}
# Añadir etiquetas a cada conjunto
genes_5 <- filtered_1 %>%
  mutate(`n=5` = TRUE) %>%
  select(Hugo_Symbol, `n=5`)

genes_10 <- filtered_2 %>%
  mutate(`n=10` = TRUE) %>%
  select(Hugo_Symbol, `n=10`)

genes_15 <- filtered_3 %>%
  mutate(`n=15` = TRUE) %>%
  select(Hugo_Symbol, `n=15`)

# Full join para unir los genes de los 3 conjuntos
genes_comparison <- full_join(genes_5, genes_10, by = "Hugo_Symbol") %>%
  full_join(genes_15, by = "Hugo_Symbol") %>%
  mutate(across(c(`n=5`, `n=10`, `n=15`), ~ ifelse(is.na(.), FALSE, .)))

# Clasificación según en cuántas listas aparece
genes_comparison <- genes_comparison %>%
  mutate(classification = case_when(
    `n=5` + `n=10` + `n=15` == 3 ~ "common_all",
    `n=5` + `n=10` + `n=15` == 2 ~ "common_2",
    `n=5` ~ "n=5",
    `n=10` ~ "n=10",
    `n=15` ~ "n=15"
  ))

genes_comparison
```

Todos los genes que están en esta lista son susceptibles, y los que están en al menos 2, tienen gran probabilidad

##### 2ª Aproximación - Uso de "dNdSCV": 

Parámetros de la función *dndscv*
dndscv(
  mutations,
  gene_list = NULL,
  refdb = "hg19",
  sm = "192r_3w",
  kc = "cgc81",
  cv = "hg19",
  max_muts_per_gene_per_sample = 3,
  max_coding_muts_per_sample = 3000,
  use_indel_sites = T,
  min_indels = 5,
  maxcovs = 20,
  constrain_wnon_wspl = T,
  outp = 3,
  numcode = 1,
  outmats = F,
  mingenecovs = 500,
  onesided = F,
  dc = NULL
)


Habria que convertir el MAF en una df  --> mutations:	
Table of mutations (5 columns: sampleID, chr, pos, ref, alt). Only list independent events as mutations.

SampleID espero que se refiera al barcode

```{r}
# Instala y carga los paquetes necesarios
if (!requireNamespace("dndscv", quietly=TRUE)) {
  install.packages("remotes")
  remotes::install_github("im3sanger/dndscv")
}
library(dndscv)
library(dplyr)
library(janitor)
```


```{r}
# Preparamos el MAF (sin esto detecta columna duplicada)
luad_df <- luad@data
luad_df <- luad_df %>% clean_names(case = "snake")
```


```{r}
# 1) Preparamos la tabla de mutaciones
mutations <- luad_df %>%
  filter(variant_classification %in% c(
    "Missense_Mutation",
    "Nonsense_Mutation",
    "Splice_Site",
    "Frame_Shift_Del",
    "Frame_Shift_Ins"
  )) %>%
  transmute(
    sampleID = tumor_sample_barcode,      
    chr      = gsub("^chr", "", chromosome),
    pos      = start_position,
    ref      = toupper(reference_allele),
    mut      = toupper(tumor_seq_allele2)
  )

# suficientes mutaciones
n_mut <- nrow(mutations)
message("Número de mutaciones codificantes: ", n_mut)
```


```{r}
# Verificar que `mutations` es un df de 5 columnas únicas
colnames(mutations)  
```


```{r}
# 3) Ejecuta dNdSCV
library(dndscv)
dndsout <- dndscv(mutations)
```


```{r}
# 4) Extrae los drivers (qglobal_cv < 0.1)
driver_genes <- dndsout$sel_cv %>%
  filter(qglobal_cv < 0.1) %>%
  arrange(qglobal_cv)

colnames(driver_genes)
driver_genes
```

Para elegir un subconjunto más “fiable” de posibles drivers, conviene filtrar no sólo por el q-valor global (qglobal_cv) sino también por el tipo de señalización (oncogén vs supresor) y por la cantidad mínima de mutaciones que soporta esa señal estadística:

- **pglobal_cv**: Es el p-valor bruto de la prueba global que compara la tasa de mutación observada frente a la esperada en ese gen.

- **qglobal_cv**: p-valor ajustado por FDR para la prueba global (suele ser 0.1 o 0.2)

- **pallsubs_cv**:P-valor bruto considerando todas las sustituciones en el gen (para capturar efectos combinados de distintas clases de mutación).

- **pmis_cv**: P-valor bruto para mutaciones missense (enfatizar en cambio de aminoácido)

- **(n_mis + n_non + n_spl) ≥ 5**: Controla que un gen tenga al menos 5 eventos entre missense (n_mis), nonsense/stop (n_non) y splice (n_spl).
(Evitar genes con pocas mutaciones, que podrían ser artefactos o muy poco representativos).

```{r}
refined <- dndsout$sel_cv %>%
  filter(
    pglobal_cv  < 0.0001,
    qglobal_cv  < 0.0005,
    pallsubs_cv < 0.01,                 # todas las sustituciones
    pmis_cv     < 0.01,                 # efecto missense
    (n_mis + n_non + n_spl) >= 5
  ) %>%
  arrange(qglobal_cv)
nrow(refined)
head(refined, 20)

```

##### 3ª Aproximación - Uso de "MutSigCV": 

El fichero **LUAD-TP.sig_genes.txt** es un output estándar de MutSigCV v0.9 generado por el Broad Institute TCGA GDAC Firehose, y forma parte de los resultados de “Mutation Analysis (MutSigCV v0.9)” para el conjunto LUAD-TP (Lung Adenocarcinoma – Primary solid tumor). Está disponible en los archivos de nivel 4 de Firehose del 28 de enero de 2016 y también se puede descargar programáticamente con la herramienta firehose_get.


maftools::pancanComparison(
  mutsigResults = "LUAD-TP.sig_genes.txt",
  qval = 0.1,
  cohortName = "LUAD",
  normSampleSize = TRUE,
  inputSampleSize = 515,  # por ejemplo, n muestras LUAD con datos MutSigCV (verifica tu cohorte exacta)
  genesToLabel = c('TP53', 'KRAS', 'EGFR', 'STK11', 'KEAP1', 'SMARCA4'),
  labelSize = 3
)

Genera error.


### 5.ClinicalEnrichment 

La función clinicalEnrichment de Maftools utiliza la prueba exacta de Fisher para realizar comparaciones tanto por pares como por grupos, con el objetivo de detectar asociaciones entre genes mutados y características clínico-patológicas (variables categóricas).

Con

```{r}
colnames(getClinicalData(luad_kras))
```

Observamos hasta 780 columnas de datos clínicos, por lo que hay que explorar las columnas para ver qué variables son relevantes.

```{r}
genes_interes <- c("KRAS", "EGFR")

luad_kras_egfr <- subsetMaf(maf = luad,
                            genes = genes_interes,
                            mafObj = TRUE)

enr_1_kras_egfr <- clinicalEnrichment(
  maf = luad_kras_egfr,
  clinicalFeature = "gender",
  annotationDat = NULL,
  minMut = 5,
  useCNV = TRUE
)

plotEnrichmentResults(
  enrich_res = enr_1_kras_egfr
)
```
Esta es una representación simple. En cada gen, se muestra con un color la variable enriquecida: EGFR es más común en mujeres, pues aparece roja.

Luego, 47/130, como esta en mujeres, quiere decir que hay 47 mujeres mutadas en EGFR, de un total de 130 mujeres.

El 73/94, como esta en azul, significa que hay 73 hombres mutados en KRAS, de un total de 94 hombres.

Lo que se extrae de aqui es que, si bien las mutaciones en KRAS son más comunes en general, las mujeres nuestran mayor equilibrio: 64% KRAS y 36% EGFR. 

Mientras que los hombres tienen mucha mayor probabilidad de sufrir mutaciones en KRAS (78%) que en EGFR (22%).

**EGFR** Se asocia mas a no fumadores, se puede hacer un análisis de enriquecimiento por fumador/no fumador.

Saber analisis similares, interpretacion, representacion, nombres de test estadísticos, log rank...

```{r}
enr_1_kras_egfr
```

Y a continuación copio y adapto el código del paper 28 para hacer un análisis de enriquecimiento por edad, que (no se hace en el paper pero es interesante (hay que ajustarlo aun asi).

```{r}
#Fix missing information in clinical data
cd_kras = maftools::getClinicalData(luad_kras)
colnames(x = cd_kras)[37] = 'FAB_Morphology'
cd_kras$FAB_Morphology = ifelse(test = as.character(cd_kras$FAB_Morphology) == 'Not_Classified', yes = NA, no = as.character(cd_kras$FAB_Morphology))

#classifiy samples as above_60 & below_60
cd_kras$Age_group = ifelse(test = as.numeric(as.character(cd_kras$age_at_initial_pathologic_diagnosis)) > 60, yes = "above_60", no = "below_60")

#Run enrichment analysis
kras.Age_group.ce = maftools::clinicalEnrichment(maf = luad_kras, clinicalFeature = 'Age_group', annotationDat = cd_kras)
```

```{r}
plotEnrichmentResults(
  enrich_res = kras.Age_group.ce
)
```



# Análisis de Supervivencia

El análisis de supervivencia es esencial en los proyectos de secuenciación de cohortes. La función *mafSurvive* realiza el análisis de supervivencia y dibuja una curva de Kaplan-Meier agrupando las muestras según el estado de mutación de los genes definidos por el usuario o las muestras proporcionadas manualmente que conforman el grupo. 

- Curva de Kaplan-Meier: método no paramétrico para estimar la función de supervivencia a partir de datos de tiempo (eje x) hasta el evento (por ejemplo, numero de vivos, recaída) (eje y).

Esta función requiere que los datos de entrada contengan el código de barras de la muestra tumoral (asegúrese de que coincidan con los del archivo MAF), el evento binario (1/0) y el tiempo transcurrido hasta el evento.

Nuestros datos de anotación ya contienen información de supervivencia en clinicalData:

```{r}
colnames(getClinicalData(luad))[grep("time|status", colnames(getClinicalData(luad)), ignore.case = TRUE)]
getClinicalData(luad)
```
La diferencia entre OS (Overall Survival) y PFI (Progression-Free Interval) es el tipo de evento que mide cada uno:

- OS (Overall Survival): Es el tiempo total que transcurre desde el diagnóstico o el inicio del tratamiento hasta la muerte de un paciente por cualquier causa. En otras palabras, mide la supervivencia global de los pacientes.

- PFI (Progression-Free Interval): Es el tiempo desde el inicio del tratamiento hasta la progresión de la enfermedad o la muerte del paciente. Se centra exclusivamente en la falta de progresión de la enfermedad, no en la muerte por otras causas. En otras palabras, mide el tiempo hasta que la enfermedad empeora.


Por tanto:

OS: Mide cuánto vive el paciente en total, independientemente de la causa.

PFI: Mide cuánto tiempo el paciente no muestra progresión de la enfermedad después del tratamiento.

Ambos son parámetros útiles, pero el OS es más general y abarca la supervivencia total, mientras que el PFI se enfoca en la efectividad del tratamiento en términos de detención del avance de la enfermedad.

### OS general
```{r}
# Guardar OS
png("OS_KrasvsEGFR.png", width = 1000, height = 800, res = 150)
OS_KrasvsEGFR <- mafSurvival(
  maf = luad, 
  genes = c("KRAS", "EGFR"), 
  samples = NULL,
  clinicalData = NULL,
  time = "CDR_OS.time", 
  Status = "CDR_OS",
  groupNames = c("KRAS", "EGFR"),
  showConfInt = TRUE,
  addInfo = TRUE,
  col = c("maroon", "royalblue"),
  isTCGA = FALSE,
  textSize = 12
)
dev.off()
```
El p-valor es 0.0408, lo que indica que aceptamos una diferencia significativa en la supervivencia entre los dos grupos (KRAS vs EGFR). 

Los pacientes con mutaciones en EGFR tienen una supervivencia global inferior en este estudio. Esto podría implicar que los pacientes con mutación en EGFR podrían tener un pronóstico más pobre en comparación con los de KRAS.

### PFI general

```{r}
# Guardar PFI
png("PFI_KrasvsEGFR.png", width = 1000, height = 800, res = 150)
PFI_KrasvsEGFR <- mafSurvival(
  maf = luad, 
  samples = NULL,
  genes = c("KRAS", "EGFR"), 
  time = "CDR_PFI.time", 
  Status = "CDR_PFI",
  groupNames = c("KRAS", "EGFR"),
  showConfInt = TRUE,
  addInfo = TRUE,
  col = c("maroon", "royalblue"),
  isTCGA = FALSE,
  textSize = 12
)
dev.off()
```

En cambio, en el análisis de PFI, no se observan diferencias significativas, lo que sugiere que tanto los pacientes con KRAS como con EGFR tienen tiempos similares hasta la progresión del tumor. Esto implica que, aunque la supervivencia global varíe entre las mutaciones, la progresión de la enfermedad no se ve afectada de manera significativa por la mutación en uno u otro gen.


### Predecir conjuntos de genes asociados con la supervivencia:

Como se ha observado, *mafSurvival()* compara la supervivencia de pacientes mutados vs wild-type (o otra mutación), comparando de forma individual. Si le pasas "KRAS" y "EGFR", te dibuja dos curvas: una para pacientes con mutaciones en KRAS y otra para EGFR. No analiza combinaciones ni efectos conjuntos. Es útil para ver el impacto de cada gen por separado.

En cambio, *mafSurvGroup()* agrupa pacientes que tienen mutaciones simultáneas (dos o mas genes mutados) y compara ese grupo combinado con el grupo sin ninguna de esas mutaciones. Así, puedes detectar si la combinación de mutaciones tiene un valor pronóstico distinto al de cada gen por sí solo. Es útil para buscar biomarcadores combinados.

Supuestamente *survGroup* permite identificar esos grupos de genes asociados a la supervivencia, por pares

Aqui la cosa gira en torno a p53 

Puede usarse el paper como introduccion a resultados de supervivencia "pareada"

```{r}
#Using top 20 mutated genes to identify a set of genes (of size 2) to predict poor prognostic groups
prog_geneset_kras = survGroup(
  maf = luad_kras, 
  top = 20, 
  genes = NULL,
  geneSetSize = 2,
  minSamples = 5,
  clinicalData = NULL,
  time = "CDR_OS.time", 
  Status = "CDR_OS", 
  verbose = FALSE)
```

```{r}
#Using top 20 mutated genes to identify a set of genes (of size 2) to predict poor prognostic groups
prog_geneset_egfr = survGroup(
  maf = luad_egfr, 
  top = 20, 
  genes = NULL,
  geneSetSize = 2,
  minSamples = 5,
  clinicalData = NULL,
  time = "CDR_OS.time", 
  Status = "CDR_OS", 
  verbose = FALSE)
```

```{r}
prog_geneset_egfr
prog_geneset_kras
```

```{r}
library(dplyr)

# Añadir columna de cohorte antes de seleccionar columnas
kras_df <- prog_geneset_kras %>%
  mutate(Cohorte = "KRAS") %>%
  select(Gene_combination, P_value, Cohorte)

egfr_df <- prog_geneset_egfr %>%
  mutate(Cohorte = "EGFR") %>%
  select(Gene_combination, P_value, Cohorte)

# Combinar y filtrar por p-valor < 0.05
Surv_significativos <- bind_rows(kras_df, egfr_df) %>%
  filter(P_value < 0.05)

# Mostrar resultados
print(Surv_significativos)
```

```{r}
library(openxlsx)

# Guardar la tabla en un archivo Excel
write.xlsx(Surv_significativos, file = "genes_significativos_supervivencia.xlsx")
```

```{r}
#OS
mafSurvGroup(
  maf = luad, 
  geneSet = c("ZFHX4", "FLG"), 
  clinicalData = NULL,
  time = "CDR_OS.time", 
  Status = "CDR_OS",
  )
```
Usar un conjunto de genes con survGroup() sirve para identificar combinaciones mutacionales que juntas se asocian a un peor (o mejor) pronóstico. No busca solo un efecto acumulativo, sino que permite detectar sinergias entre mutaciones que no serían tan evidentes por separado.





